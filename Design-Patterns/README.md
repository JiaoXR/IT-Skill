#  常用设计模式



###  1. 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

> 注意：
>
> 1. 单例类只能有一个实例；
> 2. 单例类必须自己创建自己的唯一实例；
> 3. 单例类必须给所有其他对象提供这一实例。

####  优缺点

- 优点
  - 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例；
  - 避免对资源的多重占用（比如写文件操作）
- 缺点
  - 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

####  使用场景

1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

---

###  2. 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

- 意图

为其他对象提供一种代理以控制对这个对象的访问。

- 主要解决

直接访问对象时带来的问题。

比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

####  优缺点

- 优点
  - 职责清晰；
  - 高扩展性；
  - 智能化。
- 缺点
  - 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
  - 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

####  使用场景

按职责来划分，通常有以下使用场景：

1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

> **注意事项：** 
>
> 1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
> 2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

####  实现

![proxy](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/proxy_pattern_uml_diagram.jpg)

---

###  3. 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

- 意图

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

####  优缺点

- 优点

装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

- 缺点

多层装饰比较复杂。

####  使用场景

1. 扩展一个类的功能；
2. 动态增加功能，动态撤销。

####  实现

![decorator](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/decorator_pattern_uml_diagram.jpg)

----

###  4. 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

- 意图

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。

- 主要解决

在有多种算法相似的情况下，使用 `if…else` 所带来的复杂和难以维护。

- 使用场景

一个系统有许多许多类，而区分它们的只是他们直接的行为。

####  优缺点

- 优点
  - 算法可以自由切换；
  - 避免使用多重条件判断；
  - 扩展性良好。
- 缺点
  - 策略类会增多；
  - 所有策略类都需要对外暴露。

####  实现

![strategy](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/strategy_pattern_uml_diagram.jpg)

---

###  5. 观察者模式

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

- 意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

- 主要解决

一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

####  优缺点 

- 优点
  - 观察者和被观察者是抽象耦合的
  - 建立一套触发机制
- 缺点
  - 观察者较多的话，将所有的观察者都通知到会花费很多时间；
  - 若观察者和观察目标之间有循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；
  - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

####  实现

![observer](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/observer_pattern_uml_diagram.jpg)

---

###  6. 工厂模式

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

- 意图

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

- 使用场景

日志记录器

####  优缺点

- 优点
  - 调用者想创建一个对象，只要知道其名称即可；
  - 扩展性高：如果想增加一个产品，只要扩展一个工厂类即可；
  - 屏蔽产品的具体实现，调用者只关心产品的接口
- 缺点
  - 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

> **注意事项：**
>
> 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。
>
> 有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

####  实现

![](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/factory_pattern_uml_diagram.jpg)

---

###  7. 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

- 使用场景

系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

####  优缺点

- 优点
  - 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- 缺点
  - 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

####  实现

![](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/abstract_factory_pattern_uml_diagram.jpg)

----

###  8. 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

- 意图

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

####  优缺点

- 优点
  - 可以让任何两个没有关联的类一起运行；
  - 提高了类的复用，灵活性好；
  - 增加了类的透明度。
- 缺点
  - 过多地使用适配器，会让系统非常零乱，不易整体进行把握；
  - 由于 Java 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

> **注意事项：**
>
> 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

####  实现

![](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/adapter_pattern_uml_diagram.jpg)

---

###  9. 外观模式

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

- 意图

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

类比打开电脑（按一下电源键）：启动 CPU、启动内存、启动硬盘。

####  优缺点

- 优点
  - 减少系统相互依赖；
  - 提高灵活性；
  - 提高安全性。
- 缺点
  - 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

####  实现

![](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/facade_pattern_uml_diagram.jpg)

---














>参考链接：
>http://www.runoob.com/design-pattern/design-pattern-tutorial.html