#  常用设计模式



###  1. 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

> 注意：
>
> 1. 单例类只能有一个实例；
> 2. 单例类必须自己创建自己的唯一实例；
> 3. 单例类必须给所有其他对象提供这一实例。

####  优缺点

- 优点
  - 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例；
  - 避免对资源的多重占用（比如写文件操作）
- 缺点
  - 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

####  使用场景

1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

---

###  2. 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

- 意图

为其他对象提供一种代理以控制对这个对象的访问。

- 主要解决

直接访问对象时带来的问题。

比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

####  优缺点

- 优点
  - 职责清晰；
  - 高扩展性；
  - 智能化。
- 缺点
  - 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
  - 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

####  使用场景

按职责来划分，通常有以下使用场景：

1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

> **注意事项：** 
>
> 1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
> 2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

####  实现

![proxy](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/proxy_pattern_uml_diagram.jpg)

---

###  3. 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

- 意图

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

####  优缺点

- 优点

装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

- 缺点

多层装饰比较复杂。

####  使用场景

1. 扩展一个类的功能；
2. 动态增加功能，动态撤销。

####  实现

![decorator](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/decorator_pattern_uml_diagram.jpg)

----

###  4. 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

- 意图

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。

- 主要解决

在有多种算法相似的情况下，使用 `if…else` 所带来的复杂和难以维护。

- 使用场景

一个系统有许多许多类，而区分它们的只是他们直接的行为。

####  优缺点

- 优点
  - 算法可以自由切换；
  - 避免使用多重条件判断；
  - 扩展性良好。
- 缺点
  - 策略类会增多；
  - 所有策略类都需要对外暴露。

####  实现

![strategy](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/strategy_pattern_uml_diagram.jpg)

---

###  5. 观察者模式

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

- 意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

- 主要解决

一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

####  优缺点 

- 优点
  - 观察者和被观察者是抽象耦合的
  - 建立一套触发机制
- 缺点
  - 观察者较多的话，将所有的观察者都通知到会花费很多时间；
  - 若观察者和观察目标之间有循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；
  - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

####  实现

![observer](https://github.com/JiaoXR/IT-Skill/blob/master/pics/Design-Patterns/observer_pattern_uml_diagram.jpg)
















>参考链接：
>http://www.runoob.com/design-pattern/design-pattern-tutorial.html